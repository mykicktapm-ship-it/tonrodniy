# TONRODY · Smart Contract Dev Brief (для агента)

## 0. Контекст

TONRODY — система честных P2P-игр на сети TON между пользователями.  
Платформа:

- **не играет против пользователей**;
- **не забирает комиссию** с игровых пулов;
- **не управляет исходами раундов**.

Движение TON в игровых режимах происходит **только между игроками**.  
Доход проекта формируется **исключительно из добровольных донатов и платной кастомизации**.

Задача этого репозитория:  
Реализовать смарт-контракты TONRODY (Tact / FunC) в соответствии с этой спецификацией.

---

## 1. Цель работы агента

Собрать в одном репозитории:

1. Игровой контракт **GameCore** (ядро механики лобби и Coin Flip).
2. Контракт **Treasury** (приём донатов из Donateroom).
3. Контракт **Jetton токена проекта** (условно `TNRD`).
4. Контракт **Locker** (залоченные токены, логика разблокировки).
5. Контракт **PriceOracle** (хранение и обновление цены токена).
6. Базовые тесты и минимальные скрипты деплоя.
7. Техническую документацию по контрактам.

Агент **не придумывает новую экономику** и **не меняет механику**, а реализует то, что описано ниже.

---

## 2. Ключевые принципы и инварианты

Эти правила считаются жёсткими и не подлежат изменению в коде:

1. **Нет комиссии платформы с игровых пулов.**  
   - В любых игровых режимах (Coin Flip, публичные лобби, Donateroom) весь пул ставок игроков всегда целиком уходит победителю.

2. **Платформа не является участником игры.**
   - Контракт GameCore никогда не отправляет средства на адрес платформы или админа, кроме:
     - возвратов (refund),
     - донатов в Treasury в Donateroom-режиме (отдельно от игрового пула).

3. **Отсутствие admin-управления исходами.**
   - У GameCore нет функций:
     - “админ отменить лобби после набора пула”,
     - “админ выбрать победителя”,
     - “админ забрать пул”.
   - Любые фэйлкейсы (не набралось игроков, не пришёл рандом, истёк дедлайн) решаются **алгоритмически**, без ручного вмешательства.

4. **Игровой пул всегда = сумме ставок игроков.**
   - Coin Flip: пул = `2 * stake`.
   - N-лобби: пул = `N * stake`.

5. **Donateroom не изменяет честность игры.**
   - Игровой пул формируется только из ставок.
   - Донат (`donationAmount`) не участвует в игре и всегда направляется в Treasury.

6. **GameCore неизменяем.**
   - Контракт GameCore должен быть развёрнут без механики апгрейда:
     - без прокси,
     - без owner, способного поменять логику.
   - Новая версия возможна только как **новый контракт**, а не апгрейд старого.

---

## 3. Архитектура контрактов

Агент должен реализовать минимум следующие контракты:

1. `GameCore` — игровой контракт:
   - управление лобби и раундами,
   - Coin Flip 1v1,
   - публичные лобби (N игроков),
   - Donateroom / приватные лобби (флаги + donation).

2. `Treasury` — казначейский контракт:
   - принимает донаты из GameCore (из Donateroom),
   - хранит TON,
   - управляется мультисигом/владельцем для байбеков и добавления ликвидности.

3. `TNRD Jetton` — токен проекта:
   - стандартный jetton-контракт (TON jetton standard),
   - minter / owner токена — Treasury или отдельный minter.

4. `Locker` — контракт-замок токенов:
   - хранит залоченные токены пользователей,
   - ведёт учёт:
     - `locked[user]`,
     - `unlocked[user]`,
   - выдаёт токены пользователям при выполнении условий разблокировки.

5. `PriceOracle` — оракул цены:
   - хранит значение `price`,
   - имеет `updater`, который может менять цену,
   - предоставляет метод `get_price()` для Locker.

---

## 4. GameCore: игровые режимы и логика

### 4.1. Типы режимов

Минимум следующие режимы:

- `COIN_FLIP` — дуэль 1v1:
  - 2 игрока, одинаковая ставка,
  - победитель забирает весь пул.

- `PUBLIC_LOBBY` — публичное лобби:
  - `N` игроков, одинаковая ставка,
  - 1 победитель, получает `N * stake`.

- `DONATE_PUBLIC` — публичное лобби с донатом:
  - как `PUBLIC_LOBBY`, но каждый игрок дополнительно платит `donationAmount`,
  - игровой пул = `N * stake`,
  - донаты = `N * donationAmount` → Treasury.

- `DONATE_COINFLIP` — Coin Flip с донатом:
  - как `COIN_FLIP`, но с донатом у каждого игрока.

Приватность (приватные лобби) реализуется флагом/доп. полями, а не отдельным типом.

### 4.2. Статусы лобби

Минимальный набор:

- `CREATED` — создано,
- `FILLING` — идёт набор игроков,
- `READY` — достаточно игроков для старта,
- `RESOLVING` — в процессе определения победителя (можно объединить с READY на усмотрение),
- `FINISHED` — завершено, пул выплачен,
- `CANCELLED` — отменено (например, по дедлайну / ненабору).

### 4.3. Структура лобби (пример)

На уровне данных контракт должен хранить, как минимум:

- `id` — уникальный идентификатор лобби,
- `creator` — адрес создателя,
- `mode` — тип режима,
- `status` — статус,
- `stake_amount` — ставка одного игрока,
- `donation_amount` — размер доната (0, если режим без доната),
- `max_players` — количество слотов,
- `min_players` — обычно равно `max_players`,
- `players` — список участников,
- `winner` — адрес победителя (после завершения),
- `is_donate` — флаг донат-режима,
- `is_private` — флаг приватного лобби,
- `created_at`, `finished_at`, `resolve_deadline` — временные метки (по необходимости).

Точная реализация структуры на Tact остаётся за агентом, смысл должен быть сохранён.

### 4.4. Жизненный цикл лобби

#### Создание лобби

Функция вида: `create_lobby(...)`:

- принимает:
  - режим,
  - ставку,
  - донат (если есть),
  - количество игроков,
  - флаги приватности.
- создаёт запись лобби с `status = CREATED`.
- опционально создатель сразу вносит свою ставку и донат → тогда:
  - `players` содержит создателя,
  - статус `FILLING`.

#### Вход в лобби (join)

Функция типа: `join_lobby(lobby_id)`:

- проверки:
  - лобби существует,
  - статус позволяет вход,
  - не превышен `max_players`,
  - сумма перевода:
    - `stake_amount` для обычных,
    - `stake_amount + donation_amount` для донатных.
- действия:
  - добавление игрока в `players`,
  - если `players.length == max_players` → статус `READY` и запуск/инициация розыгрыша.

#### Розыгрыш (resolve)

Функция: `resolve_lobby(lobby_id)`:

- проверка:
  - лобби в состоянии `READY`,
  - `players.length == max_players`.
- получение случайного значения через механизм, выбранный агентом (VRF / on-chain entropy / интеграция с внешним рандомом).
- выбор индекса победителя: `winner_index = random % players.length`.
- назначение `winner = players[winner_index]`.
- расчёт:
  - `game_pool = stake_amount * players.length`.
- выплаты:
  - **игровой пул** → `winner`,
  - если лобби донатное:
    - `total_donation = donation_amount * players.length` → адрес Treasury.
- статус: `FINISHED`.

#### Отмена / рефанд (timeout / не набрали игроков)

- Если лобби не набрало нужное число игроков к `resolve_deadline`, контракты должны поддерживать:
  - перевод в `CANCELLED`,
  - возврат всех ставок игрокам.
- Судьба донатов в этом кейсе:
  - либо также возврат,
  - либо заранее описанное правило (например, остаётся донатом). Это должно быть явно зафиксировано в коде и документации.

### 4.5. Денежные потоки (итог по режимам)

- **Coin Flip:**
  - Игрок A → stake,
  - Игрок B → stake,
  - Контракт → победителю: `2 * stake`.

- **Public Lobby:**
  - `N` игроков → stake каждый,
  - Контракт → победителю: `N * stake`.

- **Donateroom (Lobby / CoinFlip):**
  - каждый игрок → `stake + donation`,
  - Контракт → победителю: `N * stake`,
  - Контракт → Treasury: `N * donation`.

GameCore **никогда** не отправляет игровые средства на системные адреса, кроме Treasury для донатов.

---

## 5. Treasury (казначейство)

Задача Treasury:

- получать TON от GameCore (donation-потоки),
- хранить баланс,
- позволять владельцу/мультисигу:
  - инициировать байбеки токена,
  - пополнять ликвидность пулов,
  - финансировать ивенты.

Требования:

- GameCore должен знать только:
  - адрес Treasury,
  - как отправить туда донат.
- Treasury **не вмешивается в игровые пулы**, не может их забирать.

---

## 6. Токен TNRD (Jetton)

Требования к токену:

- стандартный jetton-контракт (совместимый с TON экосистемой).
- Владелец/минтер:
  - Treasury или отдельный minter-контракт.
- Токен используется как:
  - награда за активность,
  - объект, который будет байбекаться за счёт TON из Treasury,
  - актив, который сначала попадает в Locker в статусе `locked`.

Базовые операции:

- `mint` (ограничен владельцем/treasury),
- `transfer`,
- `burn` (опционально).

---

## 7. Locker (замок токенов)

Locker:

- принимает токены TNRD от Treasury/минтера,
- ведёт учёт:

  - `locked[user]`,
  - `unlocked[user]` (опционально, либо сразу вывод на кошелёк).

- предоставляет основную логику:
  - `reward(user, amount)`:
    - вызывается только авторизованным адресом (Treasury / minter),
    - увеличивает `locked[user]` на `amount`,
    - фактические токены хранятся в контракте Locker.
  - `update_unlock_state()`:
    - опрашивает `PriceOracle`,
    - при достижении заданного порога цены (например, $1) и условии удержания → устанавливает флаг глобальной разблокировки (или иной схемы).
  - `claim()` / `unlockMyTokens()`:
    - вызывается пользователем,
    - при выполненных условиях:
      - уменьшает `locked[user]`,
      - отправляет TNRD токены на его адрес.

Условия разблокировки:

- завязаны на цене токена из оракула,
- параметры (порог цены, логика удержания) фиксируются в коде и не меняются произвольно.

---

## 8. PriceOracle (оракул цены)

Простой контракт с:

- `price` — текущее значение цены (тип и масштаб выбирает агент, важно задокументировать),
- `updater` — авторизованный адрес/мультисиг.

Функции:

- `update_price(new_price)` — только для `updater`,
- `get_price()` — для Locker.

Обновление цены происходит off-chain, через бэкенд / отдельный сервис, который вызывает `update_price`.

---

## 9. Security, лимиты и отсутствующие возможности

Агент должен явно заложить и задокументировать:

- лимиты:
  - минимальная/максимальная ставка,
  - максимальное количество игроков в лобби,
  - размер доната,
- защиту от:
  - переполнений,
  - странных входных данных,
  - попыток вызвать неактуальные функции (resolve до READY и т.п.).

Важно:

- **Не реализовывать**:
  - скрытые комиссии,
  - скрытые владельческие функции по управлению пулом,
  - апгрейд GameCore через один вызов.

---

## 10. События / логи (events)

Для работы фронтенда и аналитики GameCore должен выбрасывать события (или их тон-аналог):

Минимум:

- `LobbyCreated(id, creator, mode, stake, donation, max_players, is_private, is_donate)`
- `LobbyJoined(id, player)`
- `LobbyReady(id)`
- `LobbyResolved(id, winner, mode, game_pool, donation_total)`
- `LobbyCancelled(id, reason_code)`

Locker:

- `TokenRewarded(user, amount)`
- `TokensUnlocked(user, amount)`

Oracle:

- `PriceUpdated(price)`

Формат и реализация событий зависят от выбранной технологии (Tact / FunC + TON), но смысл этих событий должен быть покрыт.

---

## 11. Требования к структуре репозитория

Рекомендуемая структура (агент может уточнять, но смысл должен сохраниться):

- `contracts/`
  - `gamecore.tact`
  - `treasury.tact`
  - `tnrd_jetton.tact`
  - `locker.tact`
  - `price_oracle.tact`
  - `common/` (общие типы и константы, если нужно)

- `docs/`
  - `TONRODY-CONTRACT-SPEC.md` (текущая спецификация или её разбивка)
  - краткая инструкция по деплою

- `tests/`
  - тесты для GameCore,
  - тесты для Locker и Oracle.

---

## 12. Стиль работы агента

1. **Не менять экономику и принципы**, описанные в этом документе.
2. При необходимости детализации:
   - предлагать варианты, но не нарушать:
     - отсутствие комиссии,
     - отсутствие админ-вмешательства в исходы,
     - trustless-природу GameCore.
3. Поддерживать читаемость кода:
   - комментарии к ключевой логике,
   - отдельные секции для:
     - хранения данных,
     - обработки сообщений,
     - вычисления рандома/резолва.
4. По итогам:
   - предоставить краткое `README` по каждому контракту:
     - цель,
     - основные функции,
     - основные ограничения.

---
